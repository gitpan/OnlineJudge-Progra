.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OnlineJudge::Progra 3"
.TH OnlineJudge::Progra 3 "2014-02-07" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OnlineJudge::Progra \- (Just Another) Programming Tasks Grading System
.SH "VERSION"
.IX Header "VERSION"
Version 0.02
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use OnlineJudge::Progra;
\& 
\& # Create your soubroutine to obtain new requests to process.
\& # Returns requests to be processed.
\& sub get {
\&         #...
\&         return @requests;
\& }
\&
\& # Create your subroutine to update requests wherever you store them.
\& # Receives a processed request.
\& sub update {
\&         my $request = shift;
\&         # ...
\& }
\&
\& my $judge = OnlineJudge::Progra\->new();
\& 
\& $judge\->set_home(\*(Aq/home/progra/\*(Aq); # progra\*(Aqs home
\& $judge\->set_timeinterval(30);          # in seconds
\& 
\& $judge\->run(
\&        get_sub => sub { &get },
\&        update_sub => sub { &update }
\& );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Progra is an online judge capable of compile and test programs
written to solve a programming task.
.SH "METHODS"
.IX Header "METHODS"
.SS "set_home(/home/foo/bar)"
.IX Subsection "set_home(/home/foo/bar)"
Sets the home directory for progra files (logs, pid file, etc). If not specified,
is set to '/tmp'. Once progra starts, it creates a .pid file in its home directory. 
You should remove the .pid file created in this directory in order to stop progra.
.SS "set_timeinterval(n)"
.IX Subsection "set_timeinterval(n)"
The time interval defines the amount of time (in seconds) progra waits to check 
again for new requests to process. Default to 60 seconds.
.SS "set_background(true/false)"
.IX Subsection "set_background(true/false)"
Defines if progra runs on background or not. In case background is
set, the output and errors will be redirected to the output.log and error.log 
files found in progra's home directory. True by default.
.SS "set_logging(true/false)"
.IX Subsection "set_logging(true/false)"
Defines if progra log risky situations or not (badwords and time limits).  
Anything different than zero is considered true. True by default.
.SS "set_compiler('ext', '/path/to/compiler _SOURCECODE_ \-options _BINARY_')"
.IX Subsection "set_compiler('ext', '/path/to/compiler _SOURCECODE_ -options _BINARY_')"
Defines how source codes of a given language must be compiled. The \fB_SOURCECODE_\fR
and \fB_BINARY_\fR strings must be present (yes, with both underscores) and they
will be internally replaced by the corresponding filenames. Example:
.PP
.Vb 2
\& # how a .c file should be compiled
\& $judge\->set_compiler(\*(Aqc\*(Aq, \*(Aq/usr/bin/gcc _SOURCECODE_ \-o _BINARY_\*(Aq)
.Ve
.PP
There are some compiler strings by default:
.PP
.Vb 2
\& c: /usr/bin/gcc _SOURCECODE_ \-o _BINARY_
\& cpp: /usr/bin/g++ _SOURCECODE_ \-o _BINARY_
.Ve
.PP
If you want to avoid the output generated by compilation errors, you should
add '> /dev/null 2>&1' at the end of the string, otherwise it would be redireced
to standard output.
.SS "set_exec('ext', 'string to execute _FILE_')"
.IX Subsection "set_exec('ext', 'string to execute _FILE_')"
Defines how programs of a given language must be executed. The \fB_FILE_\fR string
must be present and it would be internally replaced by the corresponding
filename. Example:
.PP
.Vb 2
\& # how a .pl file should be \*(Aqexecuted\*(Aq
\& $judge\->set_exec(\*(Aqpl\*(Aq, \*(Aq/usr/bin/perl _FILE_\*(Aq)
\& 
\& # how a .c file should be executed
\& $judge\->set_exec(\*(Aqc\*(Aq, \*(Aq./_FILE_\*(Aq);
.Ve
.PP
There are some execution strings by default:
.PP
.Vb 4
\& pl: /usr/bin/perl _FILE_
\& c: ./_FILE_
\& cpp: ./_FILE_
\& py: /usr/bin/python _FILE_
.Ve
.SS "diff_options(string)"
.IX Subsection "diff_options(string)"
Replace options for diff command. By default are: 'biwBE'.
The \-b argument ignores extra white spaces, the \-B ignores white lines, 
the \-E ignores tab expansion, the \-w ignores all white spaces, the \-i 
ignores case differences.
.SS "load_badwords(/path/to/file.txt)"
.IX Subsection "load_badwords(/path/to/file.txt)"
Open the specified file and load the badwords into memory. They must be
separated by commas. This is quite basic and should be enhanced with 
stronger security policies.
.PP
Example: system, exec, popen, etc.
.PP
Be aware that system and \fIsystem()\fR are different words!
.SS "verbose(true/false)"
.IX Subsection "verbose(true/false)"
Defines if Progra runs in verbose. If true, it prints out every
processed request to standard output. False by default.
.SS "run(get_sub => &get, update_sub => &update)"
.IX Subsection "run(get_sub => &get, update_sub => &update)"
Runs the judge. It has two mandatory parameters, \f(CW\*(C`get_sub\*(C'\fR and 
\&\f(CW\*(C`update_sub\*(C'\fR. Both define the subroutines used to obtain new 
requests and to update processed requests.
.PP
Subroutines to obtain new requests must return an array
of hash references:
.PP
.Vb 10
\& (
\&         {
\&                 \*(Aqrid\*(Aq  => 1,
\&                 \*(Aqsourcecode\*(Aq => \*(Aq/home/progra/users/1/task1.pl\*(Aq
\&                 \*(Aqlang\*(Aq => \*(Aqpl\*(Aq,
\&                 \*(Aqcompile\*(Aq => 0,
\&                 \*(Aquserpath\*(Aq => \*(Aq/home/progra/users/1/\*(Aq,
\&                 \*(Aqtaskpath\*(Aq => \*(Aq/home/progra/tasks/1/\*(Aq,
\&                 \*(Aqtimelimit\*(Aq => 1,
\&                 \*(Aqtestcases\*(Aq => 10,
\&                 \*(Aqmaxscore\*(Aq     => 100,
\&         },
\&         {
\&                 \*(Aqrid\*(Aq  => 2,
\&                 \*(Aqsourcecode\*(Aq => \*(Aq/home/progra/users/2/task1.c\*(Aq,
\&                 \*(Aqlang\*(Aq => \*(Aqc\*(Aq,
\&                 \*(Aqcompile\*(Aq => 1,
\&                 \*(Aquserpath\*(Aq => \*(Aq/home/progra/users/2/\*(Aq
\&                 \*(Aqtaskpath\*(Aq => \*(Aq/home/progra/tasks/1/\*(Aq,
\&                 \*(Aqtimelimit\*(Aq => 1,
\&                 \*(Aqtestcases\*(Aq => 20,
\&                 \*(Aqmaxscore\*(Aq => 100,
\&         }
\& )
.Ve
.PP
You \fB\s-1MUST\s0\fR specify a \fIrid\fR, it identifies the processed request uniquely.
.PP
You \fB\s-1MUST\s0\fR specify a \fIlanguage\fR. It cannot compile and/or execute a 
source code/program if it does not know its language. The format used is 
according to its source code extension: Perl => pl, C => c, \*(C+ => cpp and
so on. The extension used must be consistent with the ones used in compile
and exec strings.
.PP
You \fB\s-1MUST\s0\fR specify a \fItestcases\fR number. It has to be consistent with the
test cases you made. If you made ten test cases, they need to be 
named from 0 to 9 with \fIinput.\fR and \fIoutput.\fR prefix, depending on if they 
are input or output files.
.PP
If you do not specify a \fImaxscore\fR, it will be 100 by default. This way 
the score obtained for every test case passed will be 100 divided by the
number of test cases.
.PP
If you do not specify a \fItimelimit\fR, it will be 1 second by default.
.PP
The compile field specifies if the source code must be compiled or not. False 
if not specified.
.PP
You \fB\s-1MUST\s0\fR specify a \fIsourcecode\fR, \fIuserpath\fR and \fItaskpath\fR. 
Test cases files \fB\s-1MUST\s0\fR be inside \fItaskpath\fR. Example:
.PP
.Vb 5
\& \-\- /home/progra/tasks/1/
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\- input.0
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\- output.0
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\- input.1
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\- output.1
.Ve
.PP
This represents a directory with \fI2\fR test cases.
.PP
Subroutines to update processed requests must receive a hash 
structure like this:
.PP
.Vb 7
\& {
\&         \*(Aqrid\*(Aq => 1,
\&         \*(Aqgrade\*(Aq => 100,
\&         \*(Aqtimemarked\*(Aq => 1233455,
\&         \*(Aqexecutiontime\*(Aq => 0.001,
\&         \*(Aqcomment\*(Aq => \*(AqAC\*(Aq
\& }
.Ve
.PP
The timemarked field is an Unix time stamp, it records the time when the
request was processed. The execution time field is the average execution
time of all test cases. The comment field is a string that represents the
state of the request. The possible values are:
.PP
.Vb 7
\& AC. Accepted, the program passed all test cases.
\& WA. Wrong Answer, the program didn\*(Aqt pass all test cases.
\& PC. Processing, the source code is in the queue waiting to be processed.
\& TL. Time Limit Exceeded, the program ran out of time.
\& CE. Compilation Error, there was an error while trying to compile the source code.
\& BW: $word. The forbidden word $word was found in the source code.
\& IE. Internal Error, something went wrong in progra, check the error.log file.
.Ve
.PP
Note: when a bad/forbidden word is found in the source code or a time limit happens 
when executing it, a directory named \*(L"logged\*(R" will be created and the source code
that caused the security breach will be saved with the format \*(L"requestid_hourmin.ext\*(R"
.PP
Progra will return the result of a request inmediately after processing it, 
so the update subroutine must receive only one request at a time. Progra will call 
this subroutine for each request processed.
.SH "BUGS"
.IX Header "BUGS"
No bugs found so far.
.SH "TODO"
.IX Header "TODO"
There are lots of things to do:
.IP "Implement some kind of sandbox for safely test and compile." 4
.IX Item "Implement some kind of sandbox for safely test and compile."
.PD 0
.IP "Try with distributed processing." 4
.IX Item "Try with distributed processing."
.IP "Create working modules that use progra." 4
.IX Item "Create working modules that use progra."
.PD
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 1
\& israel leiva \- <ilv AT cpan DOT org>
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 4
\& This program is free software: you can redistribute it and/or modify
\& it under the terms of the GNU General Public License as published by
\& the Free Software Foundation, either version 3 of the License, or
\& (at your option) any later version.
\&
\& This program is distributed in the hope that it will be useful,
\& but WITHOUT ANY WARRANTY; without even the implied warranty of
\& MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
\& GNU General Public License for more details.
\&
\& http://www.gnu.org/licenses/
.Ve
